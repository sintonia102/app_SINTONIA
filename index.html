<!DOCTYPE html>
<html lang="es" class="dark">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>SINTONIA</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600;700&display=swap" rel="stylesheet">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.1/css/all.min.css">
    <style>
        /* Variables CSS para temas claro y oscuro */
        :root {
            --bg-light: #f0f2f5;
            --text-light: #1c1e21;
            --card-light: #ffffff;
            --primary-light: #1877f2;
            --shadow-light: rgba(0, 0, 0, 0.1);

            --bg-dark: #121212;
            --text-dark: #e4e6eb;
            --card-dark: #1e1e1e;
            --primary-dark: #2596be;
            --shadow-dark: rgba(255, 255, 255, 0.1);
        }
        
        /* Estilos para el tema claro */
        html.light {
            --bg-color: var(--bg-light);
            --text-color: var(--text-light);
            --card-color: var(--card-light);
            --primary-color: var(--primary-light);
            --shadow-color: var(--shadow-light);
        }

        /* Estilos para el tema oscuro */
        html.dark {
            --bg-color: var(--bg-dark);
            --text-color: var(--text-dark);
            --card-color: var(--card-dark);
            --primary-color: var(--primary-dark);
            --shadow-color: var(--shadow-dark);
        }

        /* Estilos generales del cuerpo */
        body {
            font-family: 'Inter', sans-serif;
            background-color: var(--bg-color);
            color: var(--text-color);
            transition: background-color 0.3s, color 0.3s;
        }

        /* Estilos para las tarjetas (elementos con sombra y fondo) */
        .card {
            background-color: var(--card-color);
            box-shadow: 0 4px 12px var(--shadow-color);
            transition: background-color 0.3s;
        }

        /* Estilos para botones de ícono */
        .btn-icon {
            background-color: transparent;
            color: var(--text-color);
            border: 1px solid transparent;
            transition: all 0.2s ease-in-out;
        }

        /* Efecto hover para botones de ícono */
        .btn-icon:hover {
            color: var(--primary-color);
            transform: scale(1.1);
        }
        
        /* Estilo activo para botones de ícono */
        .btn-icon.active {
            color: var(--primary-color);
        }

        /* Estilos para botones primarios */
        .btn-primary {
            background-color: var(--primary-color);
            color: white;
            transition: background-color 0.3s;
        }
        /* Efecto hover para botones primarios */
        .btn-primary:hover {
            opacity: 0.9;
        }

        /* Estilos para el visualizador de audio (canvas) */
        #visualizer {
            width: 100%;
            height: 100%;
            aspect-ratio: 16 / 9; /* Mantener la proporción 16:9 */
            background-color: #000;
            border-radius: 0.5rem;
        }

        /* Estilos para el contenedor de video (AJUSTADO PARA NUEVA POSICIÓN) */
        #videoContainer {
            width: 100%;
            /* No más position: absolute, top, left, z-index */
            aspect-ratio: 16 / 9; /* Mantener la proporción 16:9 */
            /* Añadido para espaciado en la nueva ubicación */
            margin-top: 1rem; 
        }
        
        /* Estilos para el iframe de video */
        #videoContainer iframe {
            width: 100%;
            height: 100%;
            border-radius: 0.5rem;
        }

        /* Animación de desvanecimiento para las efemérides */
        .efemeride-fade {
            animation: fadeInOut 8s infinite;
        }

        /* Keyframes para la animación de desvanecimiento */
        @keyframes fadeInOut {
            0%, 100% { opacity: 0; }
            15%, 85% { opacity: 1; }
        }

        /* Estilos para el interruptor de tema (toggle switch) */
        .switch {
            position: relative;
            display: inline-block;
            width: 60px;
            height: 34px;
        }
        .switch input { 
            opacity: 0;
            width: 0;
            height: 0;
        }
        .slider {
            position: absolute;
            cursor: pointer;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background-color: #ccc;
            transition: .4s;
            border-radius: 34px;
        }
        .slider:before {
            position: absolute;
            content: "";
            height: 26px;
            width: 26px;
            left: 4px;
            bottom: 4px;
            background-color: white;
            transition: .4s;
            border-radius: 50%;
        }
        input:checked + .slider {
            background-color: var(--primary-color);
        }
        input:checked + .slider:before {
            transform: translateX(26px);
        }

        /* Estilos para el modal de detalles de efemérides */
        .modal-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.7);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 1000;
        }

        .modal-content {
            background-color: var(--card-color);
            color: var(--text-color);
            padding: 1.5rem;
            border-radius: 0.75rem;
            max-width: 90%;
            max-height: 90%;
            overflow-y: auto;
            position: relative;
            box-shadow: 0 8px 20px var(--shadow-color);
        }

        .modal-close-btn {
            position: absolute;
            top: 0.75rem;
            right: 0.75rem;
            background: none;
            border: none;
            font-size: 1.5rem;
            color: var(--text-color);
            cursor: pointer;
        }
    </style>
</head>
<body class="antialiased">

    <div class="min-h-screen w-full flex flex-col items-center justify-center p-4">
        
        <main class="card w-full max-w-lg rounded-xl p-4 sm:p-6 space-y-4">
            
            <!-- Encabezado de la aplicación -->
            <header class="flex justify-between items-center">
                <h1 class="text-3xl font-bold" style="color: var(--primary-color);">SINTONIA</h1>
                <div class="flex items-center space-x-2">
                    <i class="fa-solid fa-sun text-yellow-400"></i>
                    <label class="switch">
                        <input type="checkbox" id="theme-toggle" checked>
                        <span class="slider"></span>
                    </label>
                    <i class="fa-solid fa-moon text-indigo-400"></i>
                </div>
            </header>

            <!-- Pantalla del reproductor (solo para el vúmetro, el video estará en otro div) -->
            <div id="player-display" class="relative w-full rounded-lg overflow-hidden">
                <canvas id="visualizer"></canvas>
            </div>
            
            <!-- Etiqueta de la estación actual -->
            <div id="station-display-container" class="text-center -mt-2">
                 <p id="current-station-label" class="text-sm font-semibold opacity-80"></p>
            </div>

            <!-- Elemento de audio (oculto) -->
            <audio id="radio-player" crossorigin="anonymous"></audio>

            <!-- Controles de la radio -->
            <div class="flex flex-col space-y-4" id="radio-controls">
                <div class="flex items-center justify-center space-x-4">
                    <button id="play-pause-btn" class="text-4xl w-16 h-16 flex items-center justify-center rounded-full btn-primary shadow-lg">
                        <i class="fas fa-play"></i>
                    </button>
                </div>
                <div class="flex items-center space-x-2">
                    <i class="fas fa-volume-down"></i>
                    <input id="volume-slider" type="range" min="0" max="1" step="0.01" value="0.8" class="w-full h-2 bg-gray-200 rounded-lg appearance-none cursor-pointer dark:bg-gray-700">
                    <i class="fas fa-volume-up"></i>
                </div>
            </div>
            
            <!-- Contenedor del video (NUEVA POSICIÓN) -->
            <div id="videoContainer" class="hidden">
                <!-- El iframe se inyectará aquí con JavaScript -->
            </div>

            <!-- Íconos de acción -->
            <div class="grid grid-cols-4 sm:grid-cols-6 gap-2 text-center text-xs">
                 <div class="flex flex-col items-center">
                    <button id="change-source-btn" class="btn-icon text-2xl"><i class="fa-solid fa-music"></i></button>
                    <span>Cambiar</span>
                </div>
                <div class="flex flex-col items-center">
                    <button id="vumeter-toggle-btn" class="btn-icon text-2xl"><i class="fa-solid fa-sliders"></i></button>
                    <span>Vúmetro</span>
                </div>
                <div class="flex flex-col items-center">
                    <button id="video-toggle-btn" class="btn-icon text-2xl"><i class="fa-solid fa-tv"></i></button>
                    <span id="video-toggle-label">Ver TV</span>
                </div>
                <div class="flex flex-col items-center">
                     <button id="like-btn" class="btn-icon text-2xl">
                        <i class="far fa-heart"></i>
                    </button>
                    <span id="like-count">0</span>
                </div>
                <div class="flex flex-col items-center">
                    <button id="share-btn" class="btn-icon text-2xl"><i class="fa-solid fa-share-nodes"></i></button>
                    <span>Compartir</span>
                </div>
                 <div class="flex flex-col items-center">
                    <a href="http://www.sintonia102.com" target="_blank" class="btn-icon text-2xl"><i class="fa-solid fa-globe"></i></a>
                    <span>Web</span>
                </div>
            </div>

            <!-- Programadores (schedulers) -->
            <div class="space-y-4 pt-4 border-t border-[var(--shadow-color)]">
                <!-- Programador de inicio -->
                <div class="flex items-center justify-between">
                     <div class="flex items-center space-x-2">
                        <i class="far fa-clock"></i>
                        <input type="datetime-local" id="start-time-input" class="p-1 rounded bg-transparent border border-[var(--shadow-color)] text-sm">
                    </div>
                    <button id="set-start-btn" class="btn-primary px-3 py-1 text-sm rounded-md">Programar</button>
                </div>
                 <!-- Programador de parada -->
                <div class="flex items-center justify-between">
                    <div class="flex items-center space-x-2">
                        <i class="fas fa-stopwatch"></i>
                        <input type="number" id="stop-time-input" placeholder="Minutos" class="p-1 w-24 rounded bg-transparent border border-[var(--shadow-color)] text-sm">
                    </div>
                    <button id="set-stop-btn" class="btn-primary px-3 py-1 text-sm rounded-md">Apagar en</button>
                </div>
            </div>
            
            <!-- Efemérides -->
            <div id="efemerides-container" class="mt-4 p-3 rounded-lg text-center flex flex-col items-center justify-center" style="background: linear-gradient(45deg, var(--primary-color), #4a00e0);">
                <div id="efemeride-content" class="text-white font-semibold text-sm mb-2">
                    <!-- El contenido se inyectará aquí -->
                </div>
                 <button id="elaborate-efemeride-btn" class="btn-primary px-3 py-1 text-sm rounded-md shadow-md">
                    ✨ Más sobre esto
                </button>
            </div>
            
             <!-- Caja de mensajes (para notificaciones) -->
             <div id="message-box" class="hidden fixed bottom-5 right-5 bg-green-500 text-white px-4 py-2 rounded-lg shadow-lg"></div>

        </main>
    </div>

    <!-- Modal para la información de la efeméride generada por IA -->
    <div id="ai-info-modal" class="modal-overlay hidden">
        <div class="modal-content">
            <button class="modal-close-btn" id="modal-close-btn">&times;</button>
            <h3 class="text-lg font-bold mb-3" style="color: var(--primary-color);">Detalles de la Efeméride</h3>
            <div id="ai-info-content" class="text-sm">
                <!-- Contenido generado por IA aquí -->
            </div>
        </div>
    </div>

    <script type="module">
        // Importa las funciones necesarias de Firebase SDKs
        import { initializeApp } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-app.js";
        import { getAuth, signInAnonymously, signInWithCustomToken, onAuthStateChanged } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-auth.js";
        import { getFirestore, doc, getDoc, setDoc, updateDoc, onSnapshot, increment } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-firestore.js";

        document.addEventListener('DOMContentLoaded', async () => {
            // --- Elementos del DOM (Declarados al inicio para evitar ReferenceError) ---
            const radioPlayer = document.getElementById('radio-player');
            const playPauseBtn = document.getElementById('play-pause-btn');
            const volumeSlider = document.getElementById('volume-slider');
            const changeSourceBtn = document.getElementById('change-source-btn');
            const vumeterToggleBtn = document.getElementById('vumeter-toggle-btn');
            const videoToggleBtn = document.getElementById('video-toggle-btn');
            const videoToggleLabel = document.getElementById('video-toggle-label');
            const videoContainer = document.getElementById('videoContainer');
            const likeBtn = document.getElementById('like-btn');
            const likeCountSpan = document.getElementById('like-count');
            const shareBtn = document.getElementById('share-btn');
            const themeToggle = document.getElementById('theme-toggle');
            const messageBox = document.getElementById('message-box');
            const canvas = document.getElementById('visualizer');
            const canvasCtx = canvas.getContext('2d');
            const currentStationLabel = document.getElementById('current-station-label');
            const radioControls = document.getElementById('radio-controls');
            const stationDisplayContainer = document.getElementById('station-display-container');
            
            const startTimeInput = document.getElementById('start-time-input');
            const setStartBtn = document.getElementById('set-start-btn');
            const stopTimeInput = document.getElementById('stop-time-input');
            const setStopBtn = document.getElementById('set-stop-btn');

            // Elementos para la nueva función de efemérides LLM
            const elaborateEfemerideBtn = document.getElementById('elaborate-efemeride-btn');
            const efemerideContentDiv = document.getElementById('efemeride-content');
            const aiInfoModal = document.getElementById('ai-info-modal');
            const modalCloseBtn = document.getElementById('modal-close-btn');
            const aiInfoContentDiv = document.getElementById('ai-info-content');


            // --- Configuración de Firebase ---
            // Usamos las variables globales proporcionadas por el entorno de Canvas
            // Si estás en GitHub Pages o localmente, descomenta y usa tus propias credenciales.
            // Si estás en Canvas, estas variables globales serán inyectadas.

            const firebaseConfig = {
                apiKey: "AIzaSyDomYzzPU9zxP9KdMGKvOrrNlwt0RLVE7Y",
                authDomain: "appsintonia-66989.firebaseapp.com",
                projectId: "appsintonia-66989",
                storageBucket: "appsintonia-66989.firebasestorage.app",
                messagingSenderId: "61116779380",
                appId: "1:61116779380:web:e42c0f702296b17b153a21"
                // measurementId: "G-3KWXJ5KHRF" // No es necesario para esta funcionalidad
            };
            
            // Para despliegues fuera de Canvas (ej. GitHub Pages), usa tu propio appId directamente.
            // Para Canvas, la variable __app_id se usa automáticamente.
            const appIdForFirestore = typeof __app_id !== 'undefined' ? __app_id : firebaseConfig.appId;

            let app, db, auth;
            let userId = 'anonymous'; // Default userId
            let globalLikeDocRef = null; // Se inicializará después de que Firebase esté listo

            // Función para mostrar mensajes
            function showMessage(text, duration = 3000) {
                messageBox.textContent = text;
                messageBox.classList.remove('hidden');
                setTimeout(() => {
                    messageBox.classList.add('hidden');
                }, duration);
            }

            try {
                // Si __firebase_config existe (estamos en Canvas), úsalo. Si no, usa firebaseConfig.
                const currentFirebaseConfig = typeof __firebase_config !== 'undefined' ? JSON.parse(__firebase_config) : firebaseConfig;
                app = initializeApp(currentFirebaseConfig);
                db = getFirestore(app);
                auth = getAuth(app);

                // Autenticación: Usar custom token si está disponible (Canvas), de lo contrario anónimo
                const initialAuthToken = typeof __initial_auth_token !== 'undefined' ? __initial_auth_token : null;
                if (initialAuthToken) {
                    await signInWithCustomToken(auth, initialAuthToken);
                } else {
                    await signInAnonymously(auth);
                }

                onAuthStateChanged(auth, (user) => {
                    if (user) {
                        userId = user.uid;
                        console.log("Firebase Auth Ready. User ID:", userId);
                        // Una vez autenticado, podemos iniciar la escucha de likes
                        // Usa el appIdForFirestore (del entorno Canvas o tu propio appId) para la ruta de Firestore
                        globalLikeDocRef = doc(db, `artifacts/${appIdForFirestore}/public/data/radioLikes/globalLikeCount`);
                        setupLikesListener();
                    } else {
                        console.log("No user is signed in.");
                        userId = 'anonymous';
                    }
                });
            } catch (e) {
                console.error("Error initializing Firebase or authenticating:", e);
                // Ahora showMessage se puede llamar con seguridad
                showMessage("Error al iniciar la base de datos (Firebase). Algunas funciones pueden no estar disponibles. Por favor, verifica tu configuración de Firebase en el código y las reglas de seguridad.", 10000);
            }

            // --- Cadenas de audio ---
            const streams = [
                { name: "SINTONIA", url: "https://stream.radioservice.org/8046/stream" },
                { name: "ZENO FM", url: "https://stream.zeno.fm/40x1zezb7nhvv" }
            ];
            let currentStreamIndex = 0;

            // --- Configuración del Vúmetro (Visualizador) ---
            let audioCtx;
            let analyser;
            let source;
            let dataArray;
            let bufferLength;
            let currentVumeterEffect = 0;
            const totalVumeterEffects = 10;
            let animationFrameId;

            // --- Datos de Efemérides (Simulación Interna) ---
            const efemerides = {
                '06-25': ["En 1978, Argentina gana su primera Copa Mundial de Fútbol.", "En 1950, comienza la Guerra de Corea."],
                '01-01': ["En 1959, triunfa la Revolución Cubana liderada por Fidel Castro.", "Día de Año Nuevo."],
                '03-24': ["En 1976, se produce el último golpe de Estado en Argentina, dando inicio a la dictadura cívico-militar.", "Día Nacional de la Memoria por la Verdad y la Justicia en Argentina."],
                '04-02': ["En 1982, tropas argentinas desembarcan en las Islas Malvinas, dando inicio a la Guerra de Malvinas.", "Día del Veterano y de los Caídos en la guerra de Malvinas."],
                '05-01': ["Día Internacional de los Trabajadores.", "En 1994, muere el piloto de Fórmula 1 Ayrton Senna en el Gran Premio de San Marino."],
                '05-25': ["En 1810, se constituye el primer gobierno patrio en Argentina, la Primera Junta.", "Día de la Revolución de Mayo en Argentina."],
                '06-20': ["En 1820, muere Manuel Belgrano, creador de la bandera argentina.", "Día de la Bandera en Argentina."],
                '07-09': ["En 1816, se firma el Acta de la Declaración de Independencia de la Argentina en Tucumán.", "Día de la Independencia en Argentina."],
                '08-17': ["En 1850, muere el General José de San Martín en Boulogne-sur-Mer, Francia.", "Paso a la Inmortalidad del General José de San Martín."],
                '10-12': ["En 1492, Cristóbal Colón llega a América.", "Día del Respeto a la Diversidad Cultural."],
                '12-10': ["En 1983, Raúl Alfonsín asume la presidencia, marcando el retorno de la democracia en Argentina.", "Día de la Restauración de la Democracia en Argentina."],
            };

            // --- Estado de la aplicación ---
            let isPlaying = false;
            let isVideoActive = false; 
            let startTimeout, stopTimeout;

            // Configura el contexto de audio para el visualizador
            function setupAudioContext() {
                if (audioCtx) {
                    console.log("AudioContext ya existe. Estado actual:", audioCtx.state);
                    if (audioCtx.state === 'suspended') {
                        audioCtx.resume().then(() => {
                            console.log("AudioContext reanudado desde setupAudioContext.");
                        }).catch(e => {
                            console.error("Error al reanudar AudioContext en setupAudioContext:", e);
                            showMessage("Error al reanudar el vúmetro: " + e.message, 5000);
                        });
                    }
                    return;
                }
                try {
                    audioCtx = new (window.AudioContext || window.webkitAudioContext)();
                    analyser = audioCtx.createAnalyser();
                    analyser.fftSize = 2048; // Tamaño de la FFT para el análisis de frecuencia
                    source = audioCtx.createMediaElementSource(radioPlayer); // Conecta el reproductor de audio al contexto
                    source.connect(analyser); // Conecta la fuente al analizador
                    analyser.connect(audioCtx.destination); // Conecta el analizador al destino (altavoces)
                    bufferLength = analyser.frequencyBinCount; // Número de datos de frecuencia
                    dataArray = new Uint8Array(bufferLength); // Array para almacenar los datos de frecuencia
                    console.log("AudioContext inicializado. Estado:", audioCtx.state);
                } catch (e) {
                    console.error("Error al configurar el contexto de audio:", e);
                    showMessage("El navegador no soporta el vúmetro o hay un problema con el stream (CORS).", 5000);
                }
            }

            // --- Controles de audio ---
            // Inicia la reproducción de la radio
            function playRadio() {
                if (isPlaying) return; // Si ya está reproduciendo, no hacer nada

                console.log("Intentando iniciar playRadio()...");

                // Asegurarse de que el AudioContext esté inicializado y reanudarlo si está suspendido
                if (!audioCtx || (audioCtx && audioCtx.state === 'suspended')) {
                    setupAudioContext(); // Esto intentará reanudar si ya existe y está suspendido
                }
                
                radioPlayer.play().then(() => {
                    console.log("Reproducción de radio iniciada con éxito.");
                    isPlaying = true;
                    playPauseBtn.innerHTML = '<i class="fas fa-pause"></i>'; // Cambia el ícono a pausa

                    // Solo inicia el dibujo del vúmetro si el modo video no está activo y el AudioContext está corriendo
                    // La comprobación de estado 'running' es crucial aquí.
                    if (!isVideoActive && audioCtx && audioCtx.state === 'running') {
                        draw();
                    } else if (audioCtx && audioCtx.state !== 'running') {
                         console.warn("AudioContext no está en estado 'running' después de play(). Vúmetro no se iniciará de inmediato.");
                    }
                }).catch(e => {
                    console.error("Error al reproducir audio:", e);
                    showMessage("No se pudo iniciar la radio. Asegúrate de interactuar con la página primero.", 6000);
                });
            }

            // Pausa la reproducción de la radio
            function pauseRadio() {
                if (!isPlaying) return; // Si no está reproduciendo, no hacer nada
                radioPlayer.pause();
                cancelAnimationFrame(animationFrameId); // Detiene la animación del vúmetro
                isPlaying = false;
                playPauseBtn.innerHTML = '<i class="fas fa-play"></i>'; // Cambia el ícono a reproducir
            }

            // Alterna entre reproducir y pausar
            function togglePlayPause() {
                if (isPlaying) {
                    pauseRadio();
                } else {
                    playRadio();
                }
            }
            
            // Cambia la fuente de audio entre las estaciones disponibles
            function toggleAudioSource() {
                const wasPlaying = isPlaying; // Guarda el estado de reproducción actual
                if (wasPlaying) {
                    pauseRadio(); // Pausa la radio antes de cambiar la fuente
                }

                currentStreamIndex = (currentStreamIndex + 1) % streams.length; // Cicla entre las fuentes
                const newStream = streams[currentStreamIndex]; // Obtiene la nueva fuente

                radioPlayer.src = newStream.url; // Asigna la nueva URL
                radioPlayer.load(); // Carga la nueva fuente
                updateStationLabel(); // Actualiza la etiqueta de la estación
                showMessage(`Cambiando a ${newStream.name}`, 2000);

                if (wasPlaying) {
                    radioPlayer.addEventListener('canplay', () => {
                         playRadio(); // Vuelve a reproducir una vez que la nueva fuente esté lista
                    }, { once: true });
                }
            }
            
            // Actualiza la etiqueta de la estación actual
            function updateStationLabel() {
                 currentStationLabel.textContent = `Ahora suena: ${streams[currentStreamIndex].name}`;
            }
            
            // Función toggleVideo: implementa la lógica para mostrar video o radio
            function toggleVideo() {
                isVideoActive = !isVideoActive; // Invierte el estado del video

                if (isVideoActive) {
                    // --- Mostrar Video ---
                    if (isPlaying) {
                        pauseRadio(); // Pausa la radio si estaba reproduciendo
                    }
                    cancelAnimationFrame(animationFrameId); // Detiene la animación del vúmetro
                    
                    // Oculta el visualizador de audio (canvas)
                    canvas.classList.add('hidden');
                    // Los controles de radio y la etiqueta de la estación permanecen visibles
                    
                    // Crea y muestra el iframe de video con las nuevas especificaciones
                    const iframe = document.createElement('iframe');
                    iframe.src = "https://player.kick.com/sintonia-tv"; 
                    iframe.setAttribute('height', '720');
                    iframe.setAttribute('width', '1280');
                    iframe.setAttribute('frameborder', '0');
                    iframe.setAttribute('scrolling', 'no');
                    iframe.setAttribute('allowfullscreen', 'true');
                    iframe.setAttribute('allow', 'autoplay; encrypted-media; picture-in-picture'); 

                    videoContainer.innerHTML = ''; // Limpia el contenedor de video
                    videoContainer.appendChild(iframe); // Agrega el iframe
                    videoContainer.classList.remove('hidden'); // Muestra el contenedor de video

                    // Actualiza el texto y el ícono del botón
                    videoToggleLabel.textContent = "Escuchar Radio";
                    videoToggleBtn.innerHTML = '<i class="fa-solid fa-radio"></i>';
                    showMessage("Cargando video de TV... Si no se ve, verifica la consola del navegador por errores de incrustación (404, CORS, X-Frame-Options).", 8000);
                } else {
                    // --- Mostrar Radio ---
                    // Oculta el video y lo limpia
                    videoContainer.classList.add('hidden');
                    videoContainer.innerHTML = '';

                    // Muestra el visualizador de audio (canvas)
                    canvas.classList.remove('hidden');
                    // Los controles de radio y la etiqueta de la estación ya están visibles

                    // Actualiza el texto y el ícono del botón
                    videoToggleLabel.textContent = "Ver TV";
                    videoToggleBtn.innerHTML = '<i class="fa-solid fa-tv"></i>';
                    
                    // Reproduce la radio automáticamente al volver
                    playRadio();
                    showMessage("Cambiando a Radio...", 3000);
                }
            }

            // Cambia el efecto de visualización del vúmetro
            function changeVumeterEffect() {
                currentVumeterEffect = (currentVumeterEffect + 1) % totalVumeterEffects; // Cicla entre los efectos
                showMessage(`Vúmetro Efecto ${currentVumeterEffect + 1}`, 1500); // Muestra el nombre del efecto
            }

            // --- Lógica de likes con Firestore ---
            // Escucha en tiempo real los cambios en el contador de likes
            function setupLikesListener() {
                if (globalLikeDocRef && db) { // Asegúrate de que globalLikeDocRef se haya inicializado
                    onSnapshot(globalLikeDocRef, (docSnap) => {
                        if (docSnap.exists()) {
                            const data = docSnap.data();
                            const currentLikes = data.count || 0;
                            likeCountSpan.textContent = `${currentLikes} Me Gusta`;
                            console.log("Likes actualizados desde Firestore:", currentLikes);
                        } else {
                            // Si el documento no existe, inicialízalo a 0
                            setDoc(globalLikeDocRef, { count: 0 }).then(() => {
                                likeCountSpan.textContent = `0 Me Gusta`;
                                console.log("Documento de likes inicializado en Firestore.");
                            }).catch(e => {
                                console.error("Error al inicializar likes:", e);
                            });
                        }
                    }, (error) => {
                        console.error("Error al escuchar likes de Firestore:", error);
                        showMessage("Error de conexión con los likes. Los 'Me Gusta' podrían no actualizarse.", 5000);
                    });
                } else {
                    console.warn("Firestore no está disponible para likes. Revisa la inicialización de Firebase.");
                    likeCountSpan.textContent = `0 Me Gusta (no persistente)`;
                }
            }
            
            // Maneja el evento de "Me gusta"
            async function handleLike() {
                if (!globalLikeDocRef) {
                    showMessage("La función de 'Me Gusta' no está disponible. Error de conexión con la base de datos.", 4000);
                    return;
                }
                
                try {
                    await updateDoc(globalLikeDocRef, {
                        count: increment(1) // Incrementa el contador de forma atómica
                    });
                    console.log("Like incrementado en Firestore.");
                    likeBtn.querySelector('i').classList.replace('far', 'fas'); // Cambia el ícono de corazón vacío a lleno
                    likeBtn.querySelector('i').classList.add('text-red-500'); // Añade color rojo
                } catch (e) {
                    console.error("Error al registrar el like en Firestore:", e);
                    showMessage("Error al registrar tu 'Me Gusta'. Intenta de nuevo.", 4000);
                }
            }

            // Maneja el evento de compartir
            function handleShare() {
                if (navigator.share) { // Si el navegador soporta la API de compartir
                    navigator.share({
                        title: 'SINTONIA Radio',
                        text: '¡Escuchá la mejor radio online!',
                        url: window.location.href // URL actual
                    }).catch(console.error);
                } else {
                    navigator.clipboard.writeText(window.location.href); // Copia el link al portapapeles
                    showMessage('¡Link copiado al portapapeles!', 2000);
                }
            }
            
            // Maneja el cambio de tema (claro/oscuro)
            function handleThemeToggle() {
                document.documentElement.classList.toggle('dark'); // Alterna la clase 'dark'
                document.documentElement.classList.toggle('light'); // Alterna la clase 'light'
            }

            // --- Lógica de programadores (schedulers) ---
            // Programa el inicio de la radio
            setStartBtn.addEventListener('click', () => {
                const startTimeValue = startTimeInput.value;
                if (!startTimeValue) {
                    showMessage("Por favor, selecciona una fecha y hora.", 3000);
                    return;
                }
                const targetTime = new Date(startTimeValue).getTime(); // Hora de inicio en milisegundos
                const now = new Date().getTime(); // Hora actual en milisegundos
                const delay = targetTime - now; // Retraso en milisegundos

                if (delay <= 0) {
                    showMessage("La hora seleccionada ya pasó.", 3000);
                    return;
                }

                clearTimeout(startTimeout); // Limpia cualquier programador anterior
                startTimeout = setTimeout(() => {
                    playRadio(); // Inicia la radio después del retraso
                    showMessage("¡La radio ha comenzado según lo programado!", 5000);
                }, delay);
                
                showMessage(`Radio programada para iniciar en ${new Date(targetTime).toLocaleString()}`, 4000);
            });

            // Programa el apagado de la radio
            setStopBtn.addEventListener('click', () => {
                const minutes = parseInt(stopTimeInput.value, 10); // Minutos para apagar
                if (isNaN(minutes) || minutes <= 0) {
                    showMessage("Ingresa un número válido de minutos.", 3000);
                    return;
                }
                const delay = minutes * 60 * 1000; // Retraso en milisegundos

                clearTimeout(stopTimeout); // Limpia cualquier programador anterior
                stopTimeout = setTimeout(() => {
                    pauseRadio(); // Pausa la radio después del retraso
                    showMessage("¡Temporizador de apagado completado!", 5000);
                }, delay);

                showMessage(`La radio se apagará en ${minutes} minuto(s).`, 4000);
            });


            // --- Lógica de Efemérides ---
            // Carga y muestra las efemérides del día
            function loadEfemerides() {
                const today = new Date();
                const day = String(today.getDate()).padStart(2, '0'); // Día actual (formato DD)
                const month = String(today.getMonth() + 1).padStart(2, '0'); // Mes actual (formato MM)
                const key = `${month}-${day}`; // Clave para buscar en el objeto efemerides
                
                const events = efemerides[key] || ["Hoy es un gran día para escuchar buena música."]; // Eventos para hoy
                let eventIndex = 0;
                
                // Actualiza el evento de efemérides
                function updateEvent() {
                    const currentEvent = events[eventIndex];
                    efemerideContentDiv.classList.remove('efemeride-fade'); // Remueve la clase para reiniciar la animación
                    void efemerideContentDiv.offsetWidth; // Truco para forzar el reinicio de la animación
                    efemerideContentDiv.classList.add('efemeride-fade'); // Añade la clase para iniciar la animación
                    efemerideContentDiv.textContent = currentEvent; // Muestra el evento
                    eventIndex = (eventIndex + 1) % events.length; // Pasa al siguiente evento
                }
                
                updateEvent(); // Muestra el primer evento inmediatamente
                setInterval(updateEvent, 8000); // Cambia el evento cada 8 segundos
            }

            // --- Funciones de dibujo del Vúmetro ---
            // Función principal de dibujo del vúmetro (loop de animación)
            function draw() {
                // El vúmetro solo se dibuja si la radio está sonando, el modo video no está activo,
                // y si el AudioContext está inicializado y en estado 'running'.
                if (!isPlaying || isVideoActive || !audioCtx || audioCtx.state !== 'running' || !dataArray) {
                    cancelAnimationFrame(animationFrameId);
                    return;
                }

                animationFrameId = requestAnimationFrame(draw); // Solicita el siguiente frame de animación
                analyser.getByteFrequencyData(dataArray); // Obtiene los datos de frecuencia
                
                // --- DEBUGGING: Revisa si dataArray tiene datos ---
                const sumData = dataArray.reduce((acc, val) => acc + val, 0);
                if (sumData === 0) {
                    console.warn("Vúmetro: dataArray está todo a cero. Esto sugiere que no se están recibiendo datos de audio del stream, probablemente debido a restricciones CORS en el servidor de radio.");
                } else {
                    // console.log("Vúmetro: la suma de los datos de audio es:", sumData);
                }
                // --- FIN DEBUGGING ---

                canvasCtx.fillStyle = '#000'; // Color de fondo del canvas
                canvasCtx.fillRect(0, 0, canvas.width, canvas.height); // Limpia el canvas

                // Dibuja el efecto de vúmetro actual
                switch (currentVumeterEffect) {
                    case 0: drawBars(); break;
                    case 1: drawCircular(); break;
                    case 2: drawWave(); break;
                    case 3: drawSunburst(); break;
                    case 4: drawGalaxy(); break;
                    case 5: drawTunnel(); break;
                    case 6: drawReflectedBars(); break;
                    case 7: drawParticleWeb(); break;
                    case 8: drawColorBlocks(); break;
                    case 9: drawTexturedLines(); break;
                }
            }
            
            // Dibuja barras de audio verticales
            const drawBars = () => {
                const barWidth = (canvas.width / bufferLength) * 2.5; // Ancho de cada barra
                let x = 0;
                for (let i = 0; i < bufferLength; i++) {
                    const barHeight = dataArray[i]; // Altura de la barra basada en la frecuencia
                    const hue = i * 2; // Color basado en el índice
                    canvasCtx.fillStyle = `hsl(${hue}, 100%, 50%)`;
                    canvasCtx.fillRect(x, canvas.height - barHeight, barWidth, barHeight); // Dibuja la barra
                    x += barWidth + 1; // Espacio entre barras
                }
            };

            // Dibuja barras circulares desde el centro
            const drawCircular = () => {
                const centerX = canvas.width / 2;
                const centerY = canvas.height / 2;
                const radius = Math.min(centerX, centerY) * 0.4; // Radio base
                for (let i = 0; i < bufferLength; i++) {
                    const barHeight = dataArray[i] / 2; // Altura de la barra
                    const angle = (i / bufferLength) * 2 * Math.PI; // Ángulo para posicionar la barra
                    const xStart = centerX + radius * Math.cos(angle);
                    const yStart = centerY + radius * Math.sin(angle);
                    const xEnd = centerX + (radius + barHeight) * Math.cos(angle);
                    const yEnd = centerY + (radius + barHeight) * Math.sin(angle);
                    const hue = i * 3; // Color
                    canvasCtx.strokeStyle = `hsl(${hue}, 100%, 70%)`;
                    canvasCtx.lineWidth = 2;
                    canvasCtx.beginPath();
                    canvasCtx.moveTo(xStart, yStart);
                    canvasCtx.lineTo(xEnd, yEnd);
                    canvasCtx.stroke();
                }
            };
            
            // Dibuja una onda de tiempo
            const drawWave = () => {
                analyser.getByteTimeDomainData(dataArray); // Obtiene datos de dominio de tiempo
                canvasCtx.lineWidth = 2;
                const hue = Date.now() / 20 % 360; // Color que cambia con el tiempo
                canvasCtx.strokeStyle = `hsl(${hue}, 100%, 50%)`;
                canvasCtx.beginPath();
                const sliceWidth = canvas.width * 1.0 / bufferLength;
                let x = 0;
                for (let i = 0; i < bufferLength; i++) {
                    const v = dataArray[i] / 128.0; // Normaliza el valor
                    const y = v * canvas.height / 2; // Posición Y
                    if (i === 0) {
                        canvasCtx.moveTo(x, y);
                    } else {
                        canvasCtx.lineTo(x, y);
                    }
                    x += sliceWidth;
                }
                canvasCtx.lineTo(canvas.width, canvas.height / 2);
                canvasCtx.stroke();
            };

            // Dibuja un efecto de explosión solar
            const drawSunburst = () => {
                const centerX = canvas.width / 2;
                const centerY = canvas.height / 2;
                for (let i = 0; i < bufferLength; i+=4) { // Salta para menos líneas
                    const barHeight = dataArray[i] * 1.5; // Altura de la línea
                    const angle = (i / bufferLength) * Math.PI * 2; // Ángulo
                    const hue = angle * 60; // Color
                    canvasCtx.save(); // Guarda el estado del canvas
                    canvasCtx.translate(centerX, centerY); // Mueve el origen al centro
                    canvasCtx.rotate(angle); // Rota el canvas
                    const gradient = canvasCtx.createLinearGradient(0, 0, barHeight, 0); // Degradado de color
                    gradient.addColorStop(0, `hsl(${hue}, 100%, 20%)`);
                    gradient.addColorStop(1, `hsl(${hue}, 100%, 70%)`);
                    canvasCtx.strokeStyle = gradient;
                    canvasCtx.lineWidth = 3;
                    canvasCtx.beginPath();
                    canvasCtx.moveTo(0, 0);
                    canvasCtx.lineTo(barHeight, 0);
                    canvasCtx.stroke();
                    canvasCtx.restore(); // Restaura el estado del canvas
                }
            };
            
            // Dibuja un efecto de galaxia con partículas
            const drawGalaxy = () => {
                const centerX = canvas.width / 2;
                const centerY = canvas.height / 2;
                for (let i = 0; i < bufferLength; i++) {
                    const value = dataArray[i];
                    if (value > 100) { // Solo dibuja si el valor es significativo
                        const radius = (value / 255) * Math.min(centerX, centerY) * 1.2; // Radio de la partícula
                        const angle = (i / bufferLength) * 2 * Math.PI + (Date.now() / 10000); // Ángulo con rotación
                        const x = centerX + radius * Math.cos(angle);
                        const y = centerY + radius * Math.sin(angle);
                        const hue = i * 2.5; // Color
                        canvasCtx.fillStyle = `hsla(${hue}, 100%, 80%, ${value/255})`; // Color con transparencia
                        canvasCtx.beginPath();
                        canvasCtx.arc(x, y, value/100, 0, Math.PI * 2); // Dibuja un círculo
                        canvasCtx.fill();
                    }
                }
            };

            // Dibuja un efecto de túnel concéntrico
            const drawTunnel = () => {
                const centerX = canvas.width / 2;
                const centerY = canvas.height / 2;
                for (let i = 0; i < bufferLength; i+=8) { // Salta para menos círculos
                    const value = dataArray[i];
                    const radius = (i / bufferLength) * (centerX * 0.8) + (value / 5); // Radio del círculo
                    if (radius > centerX) continue; // Evita dibujar fuera del canvas
                    const hue = value; // Color
                    canvasCtx.strokeStyle = `hsla(${hue}, 100%, 60%, 0.5)`; // Color con transparencia
                    canvasCtx.lineWidth = 2;
                    canvasCtx.beginPath();
                    canvasCtx.arc(centerX, centerY, radius, 0, Math.PI * 2); // Dibuja un círculo
                    canvasCtx.stroke();
                }
            };

            // Dibuja barras con reflejo vertical
            const drawReflectedBars = () => {
                const barWidth = canvas.width / bufferLength;
                const centerY = canvas.height / 2;
                for (let i = 0; i < bufferLength; i++) {
                    const barHeight = dataArray[i] / 2; // Altura de la barra
                    const hue = i * 2; // Color
                    const gradient = canvasCtx.createLinearGradient(0, centerY - barHeight, 0, centerY + barHeight); // Degradado para el reflejo
                    gradient.addColorStop(0, `hsl(${hue}, 100%, 50%)`);
                    gradient.addColorStop(0.5, `hsl(${hue}, 80%, 30%)`);
                    gradient.addColorStop(1, `hsl(${hue}, 100%, 50%)`);
                    canvasCtx.fillStyle = gradient;
                    canvasCtx.fillRect(i * barWidth, centerY - barHeight, barWidth, barHeight * 2); // Dibuja la barra y su reflejo
                }
            };
            
            // Dibuja una red de partículas conectadas
            const drawParticleWeb = () => {
                let particles = [];
                for(let i = 0; i < bufferLength; i+=8) { // Salta para menos partículas
                    const value = dataArray[i];
                    if (value > 50) { // Solo si la amplitud es suficiente
                        const angle = (i / bufferLength) * Math.PI * 2;
                        const distance = value * 1.5;
                        particles.push({ // Crea una partícula
                            x: canvas.width/2 + Math.cos(angle) * distance,
                            y: canvas.height/2 + Math.sin(angle) * distance,
                            hue: i*2
                        });
                    }
                }
                for(let i=0; i<particles.length; i++) {
                    for(let j=i; j<particles.length; j++) {
                        const dx = particles[i].x - particles[j].x;
                        const dy = particles[i].y - particles[j].y;
                        const dist = Math.sqrt(dx*dx + dy*dy); // Distancia entre partículas
                        if(dist < 50) { // Conecta si están cerca
                            canvasCtx.strokeStyle = `hsla(${particles[i].hue}, 100%, 70%, ${1 - dist/50})`; // Color con transparencia
                            canvasCtx.beginPath();
                            canvasCtx.moveTo(particles[i].x, particles[i].y);
                            canvasCtx.lineTo(particles[j].x, particles[j].y);
                            canvasCtx.stroke();
                        }
                    }
                }
            };

            // Dibuja un patrón de bloques de color
            const drawColorBlocks = () => {
                const blockSize = canvas.width / 16; // Tamaño de cada bloque
                for (let i = 0; i < 16; i++) {
                    for (let j = 0; j < 9; j++) {
                        const dataIndex = Math.floor((i*16 + j) / (16*9) * bufferLength); // Índice de datos para el bloque
                        const value = dataArray[dataIndex];
                        const hue = value * 1.5; // Color
                        canvasCtx.fillStyle = `hsl(${hue}, 100%, 50%)`;
                        canvasCtx.fillRect(i * blockSize, j * blockSize, blockSize-1, blockSize-1); // Dibuja el bloque
                    }
                }
            };
            
            // Dibuja líneas texturizadas que suben desde abajo
            const drawTexturedLines = () => {
                for (let i = 0; i < bufferLength; i += 4) { // Salta para menos líneas
                    const value = dataArray[i];
                    const y = canvas.height - value; // Posición Y de la línea
                    const hue = 180 + (value / 255) * 180; // Color
                    const gradient = canvasCtx.createLinearGradient(i * 3, y, i * 3, canvas.height); // Degradado para la textura
                    gradient.addColorStop(0, `hsla(${hue}, 100%, 70%, ${value / 255})`);
                    gradient.addColorStop(1, `hsla(${hue}, 100%, 50%, 0)`);
                    canvasCtx.fillStyle = gradient;
                    canvasCtx.fillRect(i * 3, y, 2, canvas.height - y); // Dibuja la línea
                }
            };
            
            // --- Listeners de Eventos ---
            playPauseBtn.addEventListener('click', togglePlayPause);
            changeSourceBtn.addEventListener('click', toggleAudioSource);
            vumeterToggleBtn.addEventListener('click', changeVumeterEffect);
            videoToggleBtn.addEventListener('click', toggleVideo);
            likeBtn.addEventListener('click', handleLike); // Ya no es { once: true } para permitir múltiples likes
            shareBtn.addEventListener('click', handleShare);
            themeToggle.addEventListener('change', handleThemeToggle);
            volumeSlider.addEventListener('input', (e) => {
                radioPlayer.volume = e.target.value; // Ajusta el volumen
            });

            // Listener para el nuevo botón de efemérides LLM
            elaborateEfemerideBtn.addEventListener('click', async () => {
                const currentEfemerideText = efemerideContentDiv.textContent;
                if (!currentEfemerideText || currentEfemerideText.includes("cargando") || currentEfemerideText.includes("error")) {
                    showMessage("No hay efeméride válida para detallar en este momento.", 3000);
                    return;
                }

                aiInfoContentDiv.innerHTML = '<p class="text-center text-gray-500">Cargando detalles de la IA... ✨</p>';
                aiInfoModal.classList.remove('hidden');

                try {
                    const prompt = `Explícame más sobre este evento histórico de forma concisa y en español: "${currentEfemerideText}".`;
                    let chatHistory = [];
                    chatHistory.push({ role: "user", parts: [{ text: prompt }] });

                    const payload = { contents: chatHistory };
                    const apiKey = ""; // La clave API se inyecta automáticamente en Canvas
                    const apiUrl = `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.0-flash:generateContent?key=${apiKey}`;

                    const response = await fetch(apiUrl, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify(payload)
                    });

                    if (!response.ok) {
                        const errorData = await response.json();
                        throw new Error(`Error ${response.status}: ${errorData.error.message || response.statusText}`);
                    }

                    const result = await response.json();
                    if (result.candidates && result.candidates.length > 0 &&
                        result.candidates[0].content && result.candidates[0].content.parts &&
                        result.candidates[0].content.parts.length > 0) {
                        const text = result.candidates[0].content.parts[0].text;
                        aiInfoContentDiv.textContent = text;
                    } else {
                        aiInfoContentDiv.textContent = "No se pudo generar información adicional. Intenta de nuevo.";
                        console.error("Respuesta de la API de Gemini inesperada:", result);
                    }
                } catch (error) {
                    console.error("Error al llamar a la API de Gemini:", error);
                    aiInfoContentDiv.textContent = `Error al cargar la información: ${error.message}.`;
                }
            });

            // Listener para cerrar el modal
            modalCloseBtn.addEventListener('click', () => {
                aiInfoModal.classList.add('hidden');
                aiInfoContentDiv.innerHTML = ''; // Limpiar contenido al cerrar
            });
            
            // --- Inicialización ---
            function init() {
                radioPlayer.src = streams[currentStreamIndex].url; // Establece la URL de la radio
                updateStationLabel(); // Actualiza la etiqueta de la estación
                // likeCountSpan.textContent se actualiza vía listener de Firestore
                
                // Detecta el tema preferido del sistema y lo aplica
                if (window.matchMedia && window.matchMedia('(prefers-color-scheme: light)').matches) {
                    themeToggle.checked = false; // Desmarca el toggle si es tema claro
                    document.documentElement.classList.remove('dark');
                    document.documentElement.classList.add('light');
                } else {
                    themeToggle.checked = true; // Marca el toggle si es tema oscuro
                    document.documentElement.classList.add('dark');
                    document.documentElement.classList.remove('light');
                }
                loadEfemerides(); // Carga las efemérides
                
                // Ajusta el tamaño del canvas al contenedor del reproductor y lo hace responsive
                const playerDisplay = document.getElementById('player-display');
                canvas.width = playerDisplay.clientWidth;
                canvas.height = playerDisplay.clientHeight;
                window.addEventListener('resize', () => {
                    canvas.width = playerDisplay.clientWidth;
                    canvas.height = playerDisplay.clientHeight;
                });
            }

            init(); // Llama a la función de inicialización al cargar la página
        });
    </script>
</body>
</html>
